# smvtools -- Tools around NuSMV and NuXMV
# Copyright (C) 2016 - Alexander Weigl
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA


"""Module for handling counter excample generated by nuxmv
"""
from collections import defaultdict

__author__ = "Alexander Weigl"
__date__ = "2016-03-10"


class CounterExample(object):
    """Represent a counterexample trace.

    Two special modules: `input`, `global`.
    """

    def __init__(self):
        self.modules = defaultdict(lambda: [{}])
        self.modules['input']
        self.modules['global']
        self.input_module = False

    def modules_names(self):
        return sorted(self.modules.keys())

    def variables_in_module(self, module):
        vars = set()

        for step in self.modules[module]:
            v = set(step.keys())
            vars = vars | v

        return sorted(vars)

    def parse_line(self, line):
        line = line.strip()
        if line.startswith("-> Input"):
            self.input_module = True
            self.new_step()

        elif line.startswith("-> State"):
            self.input_module = False

        else:
            key, value = parse_assign(line)
            if key:
                if self.input_module:
                    module = 'input'
                else:
                    try:
                        module, key = key.split('.', 1)
                    except ValueError:
                        module = 'global'

                self.modules[module][-1][key] = value

    def new_step(self):
        for value in self.modules.values():
            value.append({})

    def complete_states(self):
        for key, mod in self.modules.items():
            new_trace = []
            prev = None
            for step in mod:
                if new_trace:
                    d = dict(new_trace[-1])
                    d.update(step)
                    new_trace.append(d)
                else:
                    new_trace.append(step)

            self.modules[key] = new_trace

    def variable_traces(self):
        traces = defaultdict(lambda: defaultdict(list))

        for modname, module in self.modules.items():
            for step in module:
                for var, val in step.items():
                    traces[modname][var].append(val)

        return traces

    @staticmethod
    def from_file(fp):
        """Read in filename and creates a trace object.

        :param fileobj: path to nu(x|s)mv output file
        :type file: str
        :return:
        """
        trace = CounterExample()
        reached = False
        for line in fp.readlines():
            if not reached and line.strip() == "Trace Type: Counterexample":
                reached = True
                continue
            elif reached:
                trace.parse_line(line)
        return trace


def parse_assign(line: str):
    """Parse an assignment line:

    >>> parse_assign("    scenario8.Actuator_MagazinVacuumOn = TRUE")
    ('scenario8.Actuator_MagazinVacuumOn', 'TRUE')
    """
    try:
        a, b = line.split(" = ")
        return a.strip(), b.strip()
    except:
        print("Error with assignment: %s" % line, file=sys.stderr)
        return None, None
